<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Photon Journey: Sun ‚Üí Life ‚Üí Thought</title>
<style>
  :root{
    --bg:#111417; --panel:#1a1f23; --frame:#ffcc55; --text:#e9edf2; --muted:#a8b3bf;
  }
  body{margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:var(--text); display:grid; place-items:center; min-height:100dvh;}
  .wrap{max-width:740px; width:min(92vw,740px); padding:20px;}
  h1{font-weight:800; text-align:center; margin:0 0 8px;}
  p.sub{color:var(--muted); text-align:center; margin:0 0 16px;}
  .panel{position:relative; background:var(--panel); border-radius:20px; padding:18px 18px 26px; box-shadow:0 0 0 1px rgba(255,255,255,.04) inset;}
  .frame{
    position:relative; border:4px solid var(--frame); border-radius:22px; overflow:hidden;
    aspect-ratio: 3 / 4; background:#0f1113;
  }
  canvas{width:100%; height:100%; display:block;}
  /* Labels that appear near bounce points */
  .label{
    position:absolute; transform:translate(-50%,-120%); padding:6px 10px; font-size:13px;
    border-radius:12px; background:rgba(255, 204, 85, .12); color:#ffd479;
    border:1px solid rgba(255,204,85,.35); opacity:0; pointer-events:none;
    backdrop-filter: blur(2px);
    transition: opacity .35s ease, transform .35s ease;
    white-space:nowrap;
  }
  .label.show{opacity:1; transform:translate(-50%,-140%);}
  .hud{
    position:absolute; left:12px; bottom:10px; color:#9fb1c1; font-size:12px; user-select:none;
  }
  .tooltip{
    position:absolute; left:50%; top:10px; transform:translateX(-50%); font-size:12px; color:#c9d7e2;
    opacity:.75;
  }
  .hint{
    color:#90a4b8; font-size:12px; text-align:center; margin-top:8px;
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Photon Journey: Sun ‚Üí Life ‚Üí Thought</h1>
    <p class="sub">Watch how solar energy transforms into computation and consciousness.</p>

    <div class="panel">
      <div id="container" class="frame">
        <canvas id="scene" width="720" height="960"></canvas>

        <!-- Stage labels (positions set by JS to match bounces) -->
        <div id="label-sun"   class="label">‚òÄÔ∏è Sun (origin energy)</div>
        <div id="label-life"  class="label">üåø Life (photosynthesis)</div>
        <div id="label-comp"  class="label">‚ö° Computation (neurons)</div>
        <div id="label-think" class="label">üß† Thought (consciousness)</div>

        <div class="hud" id="hud">tap/click to pause ‚Ä¢ hover/tap bounces for info</div>
        <div class="tooltip" id="tip"></div>
      </div>
      <div class="hint">Tip: pause, then tap the labels to read the story beats.</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('scene');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('container');

  // Labels
  const L = {
    sun:   document.getElementById('label-sun'),
    life:  document.getElementById('label-life'),
    comp:  document.getElementById('label-comp'),
    think: document.getElementById('label-think'),
  };
  const tip = document.getElementById('tip');

  // Frame padding (matches CSS border radius look)
  const PAD = 26;

  // Path (dashed guide) & bounce points‚Äînormalized [0..1] so it scales with canvas
  const guide = [
    {x:.18, y:.18}, // start (near "sun")
    {x:.34, y:.54}, // bounce 1 (Life)
    {x:.47, y:.48}, // small deflection
    {x:.63, y:.72}, // bounce 2 (Computation)
    {x:.83, y:.90}, // bounce 3 (Thought)
  ];

  // Convert normalized to pixels inside the frame
  const toPx = p => ({
    x: PAD + p.x*(canvas.width - PAD*2),
    y: PAD + p.y*(canvas.height - PAD*2)
  });

  // Precompute pixels
  const GPX = guide.map(toPx);

  // Stage metadata for labels & tooltips
  const stages = [
    { idx: 0, el: L.sun,   title: "Sun",          desc:"A photon leaves the solar furnace." },
    { idx: 1, el: L.life,  title: "Life",         desc:"Absorbed by chlorophyll ‚Üí sugars ‚Üí stored work." },
    { idx: 3, el: L.comp,  title: "Computation",  desc:"Metabolic energy powers neurons ‚Üí spikes = bits." },
    { idx: 4, el: L.think, title: "Thought",      desc:"Patterns of spikes become perception & intent." }
  ];

  // Place labels near their target points
  const labelOffset = (dx,dy) => `translate(calc(-50% + ${dx}px), calc(-120% + ${dy}px))`;
  const placeLabel = (el, p, dx=0, dy=0) => {
    el.style.left = p.x + 'px';
    el.style.top  = p.y + 'px';
    el.style.transform = labelOffset(dx,dy);
  };
  placeLabel(L.sun,   GPX[0], -18,  8);
  placeLabel(L.life,  GPX[1],  12, -4);
  placeLabel(L.comp,  GPX[3], -6,  -6);
  placeLabel(L.think, GPX[4], -4,  -6);

  // Photon state
  let t = 0;                 // time along path (0..1 per segment)
  let seg = 0;               // current segment index
  let playing = true;
  let last = performance.now();

  // Interaction: pause/resume on click/tap
  container.addEventListener('click', () => {
    playing = !playing;
    document.getElementById('hud').textContent = playing ? 'tap/click to pause ‚Ä¢ hover/tap bounces for info'
                                                         : 'paused ‚Ä¢ tap/click to resume';
  });

  // Tooltips on label hover/tap
  const showTip = (text) => { tip.textContent = text; tip.style.opacity = .95; };
  const hideTip = () => { tip.style.opacity = 0; };
  stages.forEach(s => {
    s.el.addEventListener('mouseenter', () => showTip(`${s.title}: ${s.desc}`));
    s.el.addEventListener('mouseleave', hideTip);
    s.el.addEventListener('touchstart', () => showTip(`${s.title}: ${s.desc}`), {passive:true});
  });

  // Utility: linear interpolate point
  const lerp = (a,b,u) => ({ x:a.x+(b.x-a.x)*u, y:a.y+(b.y-a.y)*u });

  // Draw dashed guide
  function drawGuide(){
    ctx.save();
    ctx.setLineDash([10,10]);
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(120, 170, 170, .45)';
    ctx.beginPath();
    ctx.moveTo(GPX[0].x, GPX[0].y);
    for(let i=1;i<GPX.length;i++) ctx.lineTo(GPX[i].x, GPX[i].y);
    ctx.stroke();
    ctx.restore();
  }

  // Radial glow
  function glow(x,y, r=70, color='255, 200, 60', alpha=.25){
    const g = ctx.createRadialGradient(x,y,0, x,y,r);
    g.addColorStop(0, `rgba(${color}, ${alpha})`);
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  // Draw the "sun" source in the corner
  function drawSun(){
    const p = GPX[0];
    glow(p.x-40, p.y-40, 120, '255, 190, 70', .35);
    glow(p.x-40, p.y-40, 60,  '255, 210, 90', .55);
    ctx.fillStyle = '#ffd479';
    ctx.beginPath(); ctx.arc(p.x-40, p.y-40, 16, 0, Math.PI*2); ctx.fill();
  }

  // Photon visuals evolve by stage
  function drawPhoton(pos, dir, stage){
    // trailing glow
    glow(pos.x, pos.y, 46, '255, 210, 90', .20);

    // body
    ctx.save();
    ctx.translate(pos.x, pos.y);
    ctx.rotate(dir);

    if(stage === 0){ // SUN: simple disc + beam
      ctx.fillStyle = '#ffd479';
      ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
      const grad = ctx.createLinearGradient(0,0, 0,40);
      grad.addColorStop(0,'rgba(255,220,120,.9)');
      grad.addColorStop(1,'rgba(255,180,60,0)');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.moveTo(-6,0); ctx.lineTo(6,0); ctx.lineTo(0,40); ctx.closePath(); ctx.fill();
    } else if(stage === 1){ // LIFE: leaf-like wedge
      ctx.fillStyle = '#b8f28a';
      ctx.beginPath();
      ctx.moveTo(-7,2); ctx.quadraticCurveTo(0,-12, 8,2); ctx.quadraticCurveTo(0,10, -7,2);
      ctx.fill();
      ctx.fillStyle = '#defcc6'; ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
    } else if(stage === 2){ // COMPUTATION: spike (neuron)
      ctx.strokeStyle = '#a6d9ff'; ctx.lineWidth = 2.2;
      ctx.beginPath(); for(let i=0;i<5;i++){ ctx.moveTo(0,0); ctx.lineTo( (i%2?10:18), (i-2)*4 ); } ctx.stroke();
      ctx.fillStyle = '#dff0ff'; ctx.beginPath(); ctx.arc(0,0,4.5,0,Math.PI*2); ctx.fill();
    } else { // THOUGHT: bright pearl
      ctx.fillStyle = '#fff5d6';
      ctx.beginPath(); ctx.arc(0,0,9,0,Math.PI*2); ctx.fill();
      glow(0,0,60,'255,240,200',.33);
    }
    ctx.restore();
  }

  // Show/hide labels when we enter corresponding bounce indices
  function updateLabels(){
    stages.forEach((s,i) => {
      const hitting = (seg === s.idx);
      s.el.classList.toggle('show', hitting || seg > s.idx);
    });
  }

  // main loop
  function tick(now){
    const dt = Math.min(40, now-last); last = now;

    // background
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawSun();
    drawGuide();

    // advance time along segment
    if(playing){
      t += dt / 1300; // speed
      if(t >= 1){
        t = 0; seg++;
        if(seg >= GPX.length-1){ // cycle complete ‚Üí restart smoothly
          seg = 0; t = 0;
          // briefly hide labels then they‚Äôll re-appear as we pass stages again
          Object.values(L).forEach(el => el.classList.remove('show'));
        }
      }
    }

    // positions
    const A = GPX[seg], B = GPX[seg+1];
    const pos = lerp(A,B,t);
    const dir = Math.atan2(B.y-A.y, B.x-A.x);

    // stage by segment
    const stage = seg === 0 ? 0 : seg === 1 ? 1 : seg === 2 || seg === 3 ? 2 : 3;

    // draw photon
    drawPhoton(pos, dir, stage);

    // bright glow when hitting a bounce
    if(t < 0.12){ glow(A.x, A.y, 80, '255, 210, 90', 0.18); }

    // labels
    updateLabels();

    requestAnimationFrame(tick);
  }
  requestAnimationFrame((n)=>{ last=n; tick(n); });

  // Resize handling (keeps crisp canvas on mobile DPR)
  function fit(){
    const r = window.devicePixelRatio || 1;
    const rect = container.getBoundingClientRect();
    const w = Math.floor(rect.width);
    const h = Math.floor(rect.height);
    canvas.width = Math.round(w*r);
    canvas.height = Math.round(h*r);
    canvas.style.width = w+'px';
    canvas.style.height = h+'px';

    // Recompute pixel points using new canvas size
    const toPxDyn = p => ({
      x: PAD + p.x*(canvas.width - PAD*2),
      y: PAD + p.y*(canvas.height - PAD*2)
    });
    for(let i=0;i<guide.length;i++){
      GPX[i] = toPxDyn(guide[i]);
    }
    // Re-place labels
    placeLabel(L.sun,   GPX[0], -18,  8);
    placeLabel(L.life,  GPX[1],  12, -4);
    placeLabel(L.comp,  GPX[3],  -6, -6);
    placeLabel(L.think, GPX[4],  -4, -6);
  }
  new ResizeObserver(fit).observe(container);
  fit();
})();
</script>
</body>
</html>